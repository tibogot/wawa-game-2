/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/kickelhahn_tower.glb --transform 
Files: public/models/kickelhahn_tower.glb [7.22MB] > C:\Users\tibog\Documents\VSCODE\wawa-game\kickelhahn_tower-transformed.glb [901.73KB] (88%)
Author: 3DHaupt (https://sketchfab.com/dennish2010)
License: CC-BY-NC-ND-4.0 (http://creativecommons.org/licenses/by-nc-nd/4.0/)
Source: https://sketchfab.com/3d-models/kickelhahn-tower-weyeuTkdMADFF53EZq4U38mmx3P
Title: Kickelhahn Tower
*/

import React, { useRef, useEffect, useMemo } from "react";
import { useGLTF } from "@react-three/drei";
import * as THREE from "three";

export function Model({
  position = [0, 0, 0],
  scale = 1,
  rotation = [0, 0, 0],
  getTerrainHeight,
  ...props
}) {
  const groupRef = useRef(null);
  const { scene } = useGLTF("/models/kickelhahn_tower-transformed.glb");

  // Clone the scene to avoid modifying the original
  const clonedScene = useMemo(() => scene.clone(), [scene]);

  // Apply shadows to all meshes in the scene
  useEffect(() => {
    if (clonedScene) {
      clonedScene.traverse((child) => {
        if (child instanceof THREE.Mesh) {
          child.castShadow = true;
          child.receiveShadow = true;

          // Ensure materials are properly configured
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach((material) => {
                if (material instanceof THREE.Material) {
                  material.needsUpdate = true;
                }
              });
            } else if (child.material instanceof THREE.Material) {
              child.material.needsUpdate = true;
            }
          }
        }
      });
    }
  }, [clonedScene]);

  // Calculate position with terrain height
  const finalScale = Array.isArray(scale) ? scale : [scale, scale, scale];
  const finalRotation = rotation;

  // Calculate terrain height for Y position and adjust for model bottom
  useEffect(() => {
    if (groupRef.current) {
      if (getTerrainHeight) {
        // Create a temporary group with scale applied to calculate bounds
        const tempScene = clonedScene.clone();
        const tempGroup = new THREE.Group();
        tempGroup.add(tempScene);
        tempGroup.scale.set(finalScale[0], finalScale[1], finalScale[2]);

        // Compute bounding box to find the bottom of the scaled model
        const bbox = new THREE.Box3();
        bbox.setFromObject(tempGroup);

        // Get the terrain height at this position
        const terrainY = getTerrainHeight(position[0], position[2]);

        // Offset by the model's bottom so it sits on terrain
        const bottomY = bbox.min.y;
        // Use position[1] (Y value) as an offset - negative values sink deeper into ground
        const adjustedY = terrainY - bottomY + position[1];

        groupRef.current.position.y = adjustedY;
        console.log(
          `Kickelhahn Tower at [${position[0]}, ${
            position[2]
          }] -> terrain height: ${terrainY}, model bottom: ${bottomY.toFixed(
            2
          )}, Y offset: ${position[1]}, final Y: ${adjustedY.toFixed(2)}`
        );

        // Clean up temp group
        tempGroup.clear();
      } else {
        // If no terrain height function, just use the Y position directly
        groupRef.current.position.y = position[1];
      }
    }
  }, [position, getTerrainHeight, clonedScene, finalScale]);

  return (
    <group
      ref={groupRef}
      position={position}
      scale={finalScale}
      rotation={finalRotation}
      {...props}
      dispose={null}
    >
      <primitive object={clonedScene} />
    </group>
  );
}

useGLTF.preload("/models/kickelhahn_tower-transformed.glb");
